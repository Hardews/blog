---
slug: algorithm
sidebar_position: 6
---

# 算法

## 常见的排序算法

冒泡、快排、堆排、选择排序、希尔排序、插入排序、归并排序、基数排序。

Golang 版本的实现可见 [常见排序算法的 Golang 实现 ](https://hardews.cn/docs/algorithm/sort-go)



## 快排简单介绍

采用分治的思想。

- 选择一个基准（一般是第一个数），然后将数组 / 数列 重新排序。
- 将小于基准的数放在基准数的前面，将大于基准的数放在基准数的后面，这个叫做分区操作。分区的具体操作是：
  - 维护一个双指针，当左指针遇到比基准数大的数，记录下标；当右指针遇到比基准数小的数时，记录下标；然后两个下标交换。
  - 直到左指针与右指针相撞，与基准数交换。
- 递归的执行上述操作。



## 冒泡简单介绍

对于每一个元素，比较它与下一个元素的大小，如果比下一个元素大，则它俩交换。否则，继续比较下一个元素的下一个元素。直到达到顶端。这个过程像水开了泡泡从锅底浮上水面一样，所以称为冒泡排序。



## 冒泡与快排的区别

- 冒泡在一轮内只能交换相邻的元素；而快排会选取一个基准数，然后比它大的会移动到一边，比它小的移动到另一边。
- 冒泡是稳定的，相等的元素不会交换；快排是不稳定的。
- 冒泡的平均时间复杂度是 $O(n^2)$，而快排的平均时间复杂度是 $O(nlogn)$



## 归并排序简单介绍

很经典的分治思想算法。将数组平分成众多子数组。然后对子数组应用选择排序或者其他的排序，将排好序的多个数组再应用选择排序或者其他排序，合并成一个排好序的数组。直到整个数组都排好序。



## 归并排序的应用场景

- 数据量，数据规模较大时，应用归并会有比较好的效果。
- 一般应用在 **外排序** 上。**外排序** 是指处理 **超过内存限度** 的数据的排序算法，通常会将中间结果放在读写较慢的外存储器（通常为硬盘）上：
  - 排序阶段：读入能放在内存中的数据量，将其排序输出到临时文件，一次进行，将待排序数据组织为多个有序的临时文件。
  - 归并阶段：将这些临时文件组合为大的有序文件。



## 什么排序是稳定的？什么是不稳定？

- **稳定** 的排序算法：冒泡，插入，基数
- **不稳定** 的排序算法：选择，快排，堆排，希尔，归并

感觉后面那个问题有点像问不稳定的概念。一个排序算法稳不稳定要看在排序过后，数组中相同的元素是否还会按原来的顺序出现。



## 关于堆排序，堆顶元素被删除后，后面的操作？

堆排序堆顶元素被删除后，将堆顶替换为此时堆的最后一个元素，然后从堆顶开始维护这个大根堆 / 小根堆。重复删除堆顶操作，直到排序完成。



## 在计网中，两个节点的最短路径？

感觉这跟计网也没啥关系？参考图的最短路径算法（后面出一篇博客仔细讲）。

有三种常见的求 **最短路径** 的算法：

- **Dijkstra 算法**。采用贪心的思想，从开始节点到结束节点开始遍历，更新当前节点到它下一个节点的最短路径，将当前节点加入到最短路径中。直到遍历到结束节点。有个缺陷是，这个算法只能解决**正权图的单源最短路径问题**，并不能解决负权图的最短路径。这是因为 Dijkstra 算法处理的是**已经处于集合中的点**，并没有考虑不在集合中的点。比如：
  - A - > B = 4, A - > C = 5, C - > B = -3。求 A -> B 的最短路径。此时会直接给出 A -> B = 4 的路径，而不再去考虑 A - > C - > B = 2。此时，得到的最短路径就是错的。
- **Floyd 算法**。维护两个二维数组 path 和 dis，path 中记录每个节点到另一个节点中的最短距离（类似于图的邻接矩阵），dis 中记录每个节点到另一个节点是否有中间节点可以中转导致距离最短。初始时 path 为节点到每一个节点的距离，然后遍历每个节点，使用当前节点作为中转站，更新两个二维数组。需要注意的是，dis 中放置的中转站只能有一个点。那么，如何判断经过多个点呢？比如一个图有节点 A B C，当求 AC 最短路径时，如果有中转点 B ，那么我们需要判断 AB，BC 是否有中转点，然后判断是否最短，并得到全部路径。
- **Bellman-ford 算法**。它普遍会比 Dijkstra 的时间复杂度高，但是它可以处理负权图。对于这个算法，有一个概念叫 **松弛** 操作。从求最短路径的起始点开始，对当前节点的每一条边进行松弛操作，松弛操作的做法是：
  - 当前节点有两个信息 n 和 length，n 表示从哪一个节点到当前节点，length 表示从 n 节点到当前节点的当前最短距离。
  - 当 **当前节点的当前最短距离 + 可到达的下一个节点的权重 < 下一个节点的当前最短距离** 时，更新下一个节点的信息。
  - 遍历所有边，直到遍历完成且节点松弛后无任何更新。
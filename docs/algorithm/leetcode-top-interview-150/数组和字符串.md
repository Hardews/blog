---
slug: array-and-string
sidebar_position: 1
---



# 数组/字符串

## [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/?envType=study-plan-v2&envId=top-interview-150)

**思路**

倒序双指针。正序双指针比较会被覆盖，我们可以使用倒序。

遍历一遍数组，即可原地合并成功。

**代码实现**

```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    var low1, low2 = m - 1, n - 1 // 指向数组尾部的指针
    for i := m + n - 1; i >= 0; i--{
        // 将 nums2 的元素填充进 nums1 即可
        if low1 < 0{
            nums1[low2] = nums2[low2]
            low2--
            continue
        }
        // 如果 nums2 的元素已经填充完了，前面的就不用动了
        if low2 < 0{
            break
        }
        if nums1[low1] < nums2[low2]{
            nums1[i] = nums2[low2]
            low2--
        }else{
            nums1[i] = nums1[low1]
            low1--
        }
    }
}
```



## [27. 移除元素](https://leetcode.cn/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150)

**思路**

双指针，当遍历时遇到与 val 不等的值，交换元素。最后返回 low 的值即可。

**代码实现**

```go
func removeElement(nums []int, val int) int {
    var low int
    for i, v := range nums{
        if v != val{
            nums[low], nums[i] = nums[i], nums[low]
            low++
        }
    }
    return low
}
```



## [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/?envType=study-plan-v2&envId=top-interview-150)

**思路**

同向双指针遍历，当我们遇到与当前元素不一致的元素时，与 low 指针指向的下一个元素调换。

**代码实现**

```go
func removeDuplicates(nums []int) int {
    if len(nums) == 1{
        return len(nums)
    }
    var low int
    for i, v := range nums{
        if v != nums[low]{
           low++
           nums[low], nums[i] = nums[i], nums[low]
        }
    }
    return low + 1
}
```



## [80. 删除有序数组中的重复项 II ](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/submissions/474463030/?envType=study-plan-v2&envId=top-interview-150)

**思路**

双指针。

因为需要保留的是出现一次和两次的。我们可以从 2 开始遍历。当快指针遍历的元素，与慢指针的上两个元素不一样时，将其元素交换即可。

**代码实现**

```go
func removeDuplicates(nums []int) int {
    if len(nums) < 3{
        return len(nums)
    }
    var low = 2
    for i := 2; i < len(nums); i++{
        if nums[i] != nums[low - 2]{
            nums[low] = nums[i]
            low++
        }
    }
    return low
}
```

## [169. 多数元素 ](https://leetcode.cn/problems/majority-element/?envType=study-plan-v2&envId=top-interview-150)

**思路**

没啥好说的，哈希表

**代码实现**

```go
func majorityElement(nums []int) int {
    var m = make(map[int]int)
    var k = len(nums) / 2
    for _, v := range nums{
        m[v]++
        if m[v] > k{
            return v
        }
    }
    return 0
}
```


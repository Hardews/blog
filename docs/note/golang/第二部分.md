---
slug: base-data-structure
sidebar_position: 2
title: 基本数据结构
---

# Golang 的基本数据结构

## 数组

数组是 Go 语言（其他语言也是）中常见的数据结构。和它类似但也有所区别的是切片。

### 概述

我们通常会被问到：数组和链表最主要的区别是？

答案是分配的内存空间。计算机会为数组分配一块连续的内存空间来保存其中的元素（链表则是可连续可不连续），然后我们可以利用元素的索引快速访问特定的元素。

Go 语言中的数组有以下特点：

1. 初始化大小后就无法改变
2. 存储元素的类型相同
3. 大小不同的数组类型是完全不同的（甚至是不能比较）

对于前两点很好理解，而第三点可以通过下面的代码理解。

```go
var a = [3]int{1, 2, 3}
	var b = [3]int{1, 2, 3}
	var c = [3]int{2, 3, 4}
    fmt.Println(a == b) // output: true
    fmt.Println(a == c) // output: false

	// var d = [2]int{1,2}
	// fmt.Println(a == d) 无效运算: a == d(类型 [3]int 和 [2]int 不匹配)
```

而编译期间的数组类型，则由 `cmd/compile/internal/types.NewArray` 函数生成的。该类型包含两个字段，分别是类型 `Elem` 和数组大小 `Bound`。而数组是否应该在堆栈中初始化也在编译器就确定了。

```go
func NewArray(elem *Type, bound int64) *Type {
	if bound < 0 {
		Fatalf("NewArray: invalid bound %v", bound)
	}
	t := New(TARRAY)
	t.Extra = &Array{Elem: elem, Bound: bound}
	t.SetNotInHeap(elem.NotInHeap())
	return t
}
```



### 初始化

Go 语言的数组有两种不同创建方式：

- 显式指定数组大小

  ```go
  var arr = [3]int{1, 2, 3}
  ```

- 通过源代码推导数组大小

  ```go
  var arr = [...]int{1, 2, 3}
  ```

上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这是编译器对数组大小的推导。

#### 上限推导

当我们在使用第一种方式声明时，变量的类型在类型检查阶段会被提取出来，然后使用 `cmd/compile/internal/types.NewArray` 创建包含数组大小的 `cmd/compile/internal/types.Array` 结构体。

而在使用第二种声明方式时，编译器会使用 `cmd/compile/internal/gc.typecheckcomplit` 中的函数对该数组进行大小的推导。

而推导方式大概就是：遍历一遍数组中的元素，然后计算元素的数量。

那么，这种推导方式是否会对性能产生影响呢？一般不会（谁家好人初始化这么大一个数组还不写长度）。

#### 语句转换

对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 `cmd/compile/internal/gc.anylit` 函数中做两种不同的优化：

- 元素数量 <= 4，将数组中的元素直接放到栈上。
- 元素数量 > 4，将数组中的元素放置到静态区并在运行时取出。大概流程就是：
  - 获取一个唯一的 `staticname`
  - 在静态存储区初始化数组中的元素并将临时变量赋值给数组

### 访问和赋值

无论在栈上还是静态存储区，数组在内存中都是一连串的内存空间。我们可以通过：

- 指向数组开头的指针
- 数组元素的数量
- 元素类型所占空间

去表示数组。无论丢失了哪个信息，我们都无法知道这片连续的内存空间到底存储了什么数据。

对于数组越界，go 语言会验证访问数组的索引：

- 非整数，报错 `"non-integer array index %v"`
- 负数，报错 `"invalid array index %v (index must be non-negative)"`
- 索引越界，报错 `"invalid array index %v (out of bounds for %d-element array)"`

而一些简单的越界错误会在编译期间被发现。比如使用越界常量访问数组。


---
slug: base-data-structure
sidebar_position: 2
title: 基本数据结构
---

# Golang 的基本数据结构

## 数组

数组是 Go 语言（其他语言也是）中常见的数据结构。和它类似但也有所区别的是切片。

### 概述

我们通常会被问到：数组和链表最主要的区别是？

答案是分配的内存空间。计算机会为数组分配一块连续的内存空间来保存其中的元素（链表则是可连续可不连续），然后我们可以利用元素的索引快速访问特定的元素。

Go 语言中的数组有以下特点：

1. 初始化大小后就无法改变
2. 存储元素的类型相同
3. 大小不同的数组类型是完全不同的（甚至是不能比较）

对于前两点很好理解，而第三点可以通过下面的代码理解。

```go
var a = [3]int{1, 2, 3}
	var b = [3]int{1, 2, 3}
	var c = [3]int{2, 3, 4}
    fmt.Println(a == b) // output: true
    fmt.Println(a == c) // output: false

	// var d = [2]int{1,2}
	// fmt.Println(a == d) 无效运算: a == d(类型 [3]int 和 [2]int 不匹配)
```

而编译期间的数组类型，则由 `cmd/compile/internal/types.NewArray` 函数生成的。该类型包含两个字段，分别是类型 `Elem` 和数组大小 `Bound`。而数组是否应该在堆栈中初始化也在编译器就确定了。

```go
func NewArray(elem *Type, bound int64) *Type {
	if bound < 0 {
		Fatalf("NewArray: invalid bound %v", bound)
	}
	t := New(TARRAY)
	t.Extra = &Array{Elem: elem, Bound: bound}
	t.SetNotInHeap(elem.NotInHeap())
	return t
}
```



### 初始化

Go 语言的数组有两种不同创建方式：

- 显式指定数组大小

  ```go
  var arr = [3]int{1, 2, 3}
  ```

- 通过源代码推导数组大小

  ```go
  var arr = [...]int{1, 2, 3}
  ```

上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这是编译器对数组大小的推导。

#### 上限推导

当我们在使用第一种方式声明时，变量的类型在类型检查阶段会被提取出来，然后使用 `cmd/compile/internal/types.NewArray` 创建包含数组大小的 `cmd/compile/internal/types.Array` 结构体。

而在使用第二种声明方式时，编译器会使用 `cmd/compile/internal/gc.typecheckcomplit` 中的函数对该数组进行大小的推导。

而推导方式大概就是：遍历一遍数组中的元素，然后计算元素的数量。

那么，这种推导方式是否会对性能产生影响呢？一般不会（谁家好人初始化这么大一个数组还不写长度）。

#### 语句转换

对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 `cmd/compile/internal/gc.anylit` 函数中做两种不同的优化：

- 元素数量 <= 4，将数组中的元素直接放到栈上。
- 元素数量 > 4，将数组中的元素放置到静态区并在运行时取出。大概流程就是：
  - 获取一个唯一的 `staticname`
  - 在静态存储区初始化数组中的元素并将临时变量赋值给数组

### 访问和赋值

无论在栈上还是静态存储区，数组在内存中都是一连串的内存空间。我们可以通过：

- 指向数组开头的指针
- 数组元素的数量
- 元素类型所占空间

去表示数组。无论丢失了哪个信息，我们都无法知道这片连续的内存空间到底存储了什么数据。

对于数组越界，go 语言会验证访问数组的索引：

- 非整数，报错 `"non-integer array index %v"`
- 负数，报错 `"invalid array index %v (index must be non-negative)"`
- 索引越界，报错 `"invalid array index %v (out of bounds for %d-element array)"`

而一些简单的越界错误会在编译期间被发现。比如使用越界常量访问数组。



## 切片

Go 语言的切片是动态数组，长度不固定。我们可以向切片中追加元素，在容量不足时切片会自动扩容。

### 数据结构

切片可以由如下的结构体表示：

```go
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
```

- Data 是执行数组的指针，它是一片连续的内存空间。
- Len 是当前切片的长度。
- Cap 是当前切片的容量，即 Data 数组的大小。

### 实现原理

#### 初始化

初始化一个切片的方式有：

- 使用下标：

  ```go
  var a = [3]int{1, 2, 3}
  var b = a[:]
  ```

  需要注意的是，这种方式创建的切片是指向数组的指针。换句话说，修改 a 的值也会同样修改 b 的值。

  ```go
  var a = [3]int{1, 2, 3}
  var b = a[:]
  a[0] = 2
  fmt.Println(b) // output: [2,2,3]
  ```

  此时，如果使用 append 关键字，则会创建一个新的数组（也就是分配新的内存空间），修改 a 则无法修改 b。

  ```go
  var a = [3]int{1, 2, 3}
  var b = a[:]
  a[0] = 2
  fmt.Println(b) // output: [2,2,3]
  b = append(b, 2)
  a[0] = 1
  fmt.Println(b) // output: [2,2,3,2]
  ```

- 字面量：

  ```go
  var a = []int{1, 2, 3}
  ```

  - 这种初始化方法，会根据切片中的元素数量对底层数组进行大小推断并创建一个数组

  - 然后将字面量元素存储到初始化的数组中

- 关键字：

  ```go
  var a = make([]int, 0, 0) // len, cap
  ```

  在使用 make 关键字创建时，会检查 len 是否传入，并保证传入的容量 cap 一定大于或等于 len。

  ```go
  var b = append([]int{}, 0)
  ```

#### 追加和扩容

- append 关键字会返回一个新的切片。
- 如果追加元素后，切片的大小大于容量，那么就会对切片进行扩容，并将新的元素依次加入切片。

**新切片的容量是如何确定的？**

- **确认大致容量**

  ```go
  func growslice(et *_type, old slice, cap int) slice {
      // 旧切片的容量大小
  	newcap := old.cap
  	doublecap := newcap + newcap
  	if cap > doublecap {
  		newcap = cap
  	} else {
  		if old.len < 1024 {
  			newcap = doublecap
  		} else {
  			for 0 < newcap && newcap < cap {
  				newcap += newcap / 4
  			}
  			if newcap <= 0 {
  				newcap = cap
  			}
  		}
  	}
  }
  ```

  - 如果期望容量大于当前容量的两倍，使用期望容量

  - 当前切片的长度小于 1024，容量翻倍

  - 当前切片的长度大于 1024，每次增加 25% 的容量，直到新容量大于期望容量

- **内存对齐**

  - 在扩容时，为了提高内存的分配效率以及减少碎片空间，会将待申请的内存使用以下数组向上取整：

    ```go
    var class_to_size = [_NumSizeClasses]uint16{
        0,
        8,
        16,
        32,
        48,
        64,
        80,
        ...,
    }
    ```

    比如一个空切片 a，调用 append 后：

    ```go
    var a []int
    a = append(a, []int{1,2,3,4,5}...)
    ```

    这时期望分配的内存应该是 5，也就是 5 * 8 = 40byte。向上取整，实际开辟的空间为 48byte。

#### 拷贝

```go
func copy(dst []Type, src []Type) int
```

这是不常用的一个函数。在切片或数组中，它的作用是拷贝 地址为 src 的内容到 dst 上。但是切片的长度不会改变，并且只改变内容。比如

```go
var a = []int{1, 2, 3, 4}
var b = []int{5, 8, 7, 6, 5}
fmt.Println(a, b)
copy(a, b)
fmt.Println(a, b) // output: [5 8 7 6] [5 8 7 6 5]
b[0] = 1
fmt.Println(a, b) // output: [5 8 7 6] [1 8 7 6 5]
```

在编译期间，会分两种情况处理拷贝操作：

- 编译期间调用，直接 copy：

  ```go
  // 获取长度
  n := len(a)
  // 像上边说的，不能改变长度
  if n > len(b) {
      n = len(b)
  }
  if a.ptr != b.ptr {
      memmove(a.ptr, b.ptr, n*sizeof(elem(a))) 
  }
  ```

  

- 运行时调用，使用 `runtime.slicecopy` 替换运行期间调用的 `copy`：

  ```go
  func slicecopy(to, fm slice, width uintptr) int {
  	if fm.len == 0 || to.len == 0 {
  		return 0
  	}
  	n := fm.len
  	if to.len < n {
  		n = to.len
  	}
  	if width == 0 {
  		return n
  	}
  	...
  
  	size := uintptr(n) * width
  	if size == 1 {
  		*(*byte)(to.array) = *(*byte)(fm.array)
  	} else {
  		memmove(to.array, fm.array, size)
  	}
  	return n
  }
  ```

两种方法本质上都会通过 runtime.memmove 将整块内存的内容拷贝到目标的内存区域中。



## 哈希表

### 设计原理

#### 哈希函数


---
slug: computer-network
sidebar_position: 2
---



# 计算机网络

## TCP 如何创建链接？创建链接的流程？

**如何创建：**三握手。

**流程：**

1. 客户端主动打开链接（结束 CLOSED 阶段），此时服务器端被动打开链接（结束 CLOSED 阶段，进入 LISTEN 阶段）。

2. 第一步握手，客户端向服务器发送一段 TCP 报文，其中：

   - 标记位为 SYN，表示 ”请求建立新连接“；
   - 序号为 seq = X （X 一般为 1）

   随后客户端进入 SYN-SENT 阶段。

3. 服务器接收来自客户端的 TCP 报文之后，结束 LISTEN 阶段。并返回响应报文：

   - 标志位为 SYN 和 ack，表示 ”确认客户端的报文 seq 有效，服务器能够正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端已接受到数据）
   - 序号为 seq = y
   - 确认号 ack = x + 1，表示收到客户端序号并将其加 1 作为确认号的值

   随后服务器端进入 SYN-RCVD 阶段。

4. 客户端接收到确认的数据报文后，明确客户端到服务器的数据传输时正常的，结束 SYN-SENT 阶段。并返回最后一段 TCP 报文：

   - 标志位 ack = y + 1，表示 “确认收到服务器端同意链接的确认号），将确认号设置为服务器端发送的序号 seq + 1。
   - 序号 seq = x + 1，表示收到确认号 ack，将序号设置为服务器端发送的确认号。

   随后客户端进入 ESTABLISHED 阶段。

5. 此时，服务器端收到了最后一段报文后，明确从服务器端到客户端的传输时正常的。结束 SYN-SENT 阶段，进入 ESTABLISHED 阶段。

在传输的 TCP 报文中，确认号与序号都是在彼此传输的确认号与序号的基础上进行计算的。这保证了 TCP 报文传输的连贯性。一旦报文丢失，则无法继续握手，以此确保三次握手的顺利进行。



## 为什么需要三握手？两次或者一次握手不行吗？

主要是为了放置服务器端开启一些无用连接增加服务器开销，以及防止已失效的连接请求报文段突然又重新传到服务器端，因此产生了错误。

**一次握手**：如果只有一次握手，服务器端并不能知道这是否是一个有效的链接，客户端也并不知道服务器端是否成功接收了链接，并不能确保发送的数据服务器端是否能收到。

**两次握手**：如果只有两次握手，当服务器端将响应报文返回给客户端时，客户端发送第三次确认报文。如果客户端此时出错了，并没有发送确认报文，等超时重传时才继续进行握手。这时候，服务器端是一直在等待的（因为两次握手已经完成了，它认为链接已经成功建立），这样就会导致不必要的开销。

所以，三次握手是有必要的，它是保证 TCP 可靠连接以及节省资源的一大支持。



## TCP 如何断开链接？断开连接的流程？

**如何断开**：四挥手。

**流程**：连接的释放（断开）必须是一方主动释放，另一方被动释放。以客户端发起释放连接为例：

1. 首先客户端主动想要释放连接，向服务器端发送一段报文：

   - 标志位 FIN，表示 “请求释放连接”
   - 序号 seq = U

   随后客户端进入 FIN-WAIT-1 阶段，即半关闭阶段。并且停止在客户端到服务器端方向发送的数据，但是客户端仍然可以接收服务器端传输的数据。

   注意，这里不发送正常连接时传输的数据（非确认报文），而不是全部数据，所以客户端仍然可以发送确认报文。

2. 服务器端接收到结束报文后，确认客户端想要释放连接，随后服务器端结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段（半关闭状态），并返回一段报文：

   - 标志位为 ack，表示 ”接收到客户端发送的释放连接的请求“
   - 序号 seq = V
   - 确认号为 ack = U + 1，表示是在收到客户端报文的基础上，将其序号 + 1 作为确认号的值。

   随后服务器端开始准备释放服务器端到客户端方向的连接。进入 CLOSE-WAIT 阶段。

   这两次挥手让服务器端知道了客户端想释放连接，也让客户端知道服务器端了解到了想要释放连接的请求。此时，客户端可以确认关闭客户端到服务器端的连接了，并进入 FIN-WAIT-2 阶段。

3. 当服务器端发出确认报文后，经过 CLOSED-WAIT 阶段，做好了释放服务器端到客户端方向连接的准备，再次向客户端发出报文：

   - 标志位 FIN, ACK，表示 ”已经准备好释放连接“。这里的 ACK 并不是确认收到服务器端报文的确认报文。
   - 序号 seq = W
   - ack = U + 1，表示在收到客户端报文的基础上，将其序号 + 1 作为确认号的值。

   随后服务器端结束 CLOSED-WAIT 阶段，进入 LAST-ACK 阶段。停止在服务器端到客户端方向发送数据，但是服务器端仍能接收从客户端传来的数据。

4. 客户端接收到服务器端发出的 TCP 报文，确认服务器端做好释放连接的准备，结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器端发送报文：

   - 标志位 ack ，表示 ”接收到服务器准备好释放连接的信号“
   - 序号为 seq = U + 1，表示在收到服务器报文的基础上，将其确认号 ack 作为本段报文序号的值
   - 确认号 ack = W + 1，表示收到服务器报文的基础上，将其序号作为本段报文确认号的值。



## 为什么客户端需要等待 2MSL？

等待 2MSL 是为了确认服务器端是否收到客户端的 ACK 确认报文，服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。由此正确确认关闭服务器端到客户端的连接。

此时，如果服务器端没有收到确认报文，代表连接其实没有断开成功。会重新发送以保证连接能够正常断开。



## 为什么需要四挥手？

这是因为，服务器端不可能说断开就断开，它先要明确自己收到了客户端的请求（第二次挥手），然后它需要等待自己的数据传输完成后，准备好断开了，才能断开（第三次挥手）。



## TCP 是什么？

TCP 是 Transmission Control Protocol 的简称，中文名是传输控制协议。它是一种面向连接的，可靠的，基于字节流的传输层协议。



## UDP 是什么？

UDP 是 User Datagram Protocol 的简称，中文名是用户数据报协议。是 OSI 参考模型中的传输层协议，它是一种无连接的提供面向事务的**简单不可靠信息传送服务**。也就是说，它无法保证报文是否能够安全完整到达。

**拓展**（没问别答）

它的格式有两个部分

- 首部：它包括：
  - 源端口：2 字节，表示源端口号
  - 目的端口：2 字节，表示目的端口号
  - 长度：2 字节，校验 UDP 数据报的数据字段和包含 UDP 数据报首部的**伪首部**。其校验方法用 IP 分组首部校验和。伪首部是指在 TCP 分段或者 UDP 的数据报格式中，在数据报首部前加上源 IP 地址，目的 IP 地址，IP 地址分组和协议字段。它是一个临时结构，既不向上也不向下传递，仅仅只是为了保证可以校验套接字的正确性。
- 数据：顾名思义是传输的数据。



## OSI 参考（七层）模型？

开放系统互联（Open System Interconnection）。但随着时代的发展，逐渐被 TCP/IP 4 层模型淘汰。

OSI 分为 7 层，从上到下依次是：

- 应用层，网络服务与最终客户的一个接口（可以理解为人机交互画面）
- 表示层，数据的表示，安全，压缩（翻译成机器语言）
- 会话层，建立，管理，终止会话（传输到哪里，建立会话。或者哪里传输过来）
- 传输层，定义传输协议的协议端口号，以及控流和差错校验（定义怎么传输）
- 网络层，逻辑地址寻址，实现不同网络间的路径选择（找到需要传输到哪，这个哪的 ip 地址）
- 数据链路层，建立逻辑链接，进行硬件地址寻址，差错校验等功能（通过网卡，进行传输）
- 物理层，建立，维护，断开物理连接（变成信号传输啊啥的，就是真正的传输过去）



## TCP/IP 四层模型？

TCP/IP 四层模型就是将 OSI 七层模型中的上三层变为了应用层。

它相对于 OSI 七层模型来说，更简单，成本更低，效率也更高。



## QUIC 协议

QUIC: quick UDP internet connections，是一种基于 UDP 的传输层协议。


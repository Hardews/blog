---
slug: interview-sum
sidebar_position: 1
---



# 面试题汇总

本文整理一些别人的面经，以及常见的一些面试题。

<!--truncate-->

## 1. 常见的排序算法

冒泡、快排、堆排、选择排序、希尔排序、插入排序、归并排序、基数排序。

Golang 版本的实现可见 [常见排序算法的 Golang 实现 ](https://hardews.cn/sort-go)



## 2. 快排简单介绍

采用分治的思想。

- 选择一个基准（一般是第一个数），然后将数组 / 数列 重新排序。
- 将小于基准的数放在基准数的前面，将大于基准的数放在基准数的后面，这个叫做分区操作。分区的具体操作是：
  - 维护一个双指针，当左指针遇到比基准数大的数，记录下标；当右指针遇到比基准数小的数时，记录下标；然后两个下标交换。
  - 直到左指针与右指针相撞，与基准数交换。
- 递归的执行上述操作。



## 3. 冒泡简单介绍

对于每一个元素，比较它与下一个元素的大小，如果比下一个元素大，则它俩交换。否则，继续比较下一个元素的下一个元素。直到达到顶端。这个过程像水开了泡泡从锅底浮上水面一样，所以称为冒泡排序。



## 4. 冒泡与快排的区别

- 冒泡在一轮内只能交换相邻的元素；而快排会选取一个基准数，然后比它大的会移动到一边，比它小的移动到另一边。
- 冒泡是稳定的，相等的元素不会交换；快排是不稳定的。
- 冒泡的平均时间复杂度是 $O(n^2)$，而快排的平均时间复杂度是 $O(nlogn)$



## 5. 归并排序简单介绍

很经典的分治思想算法。将数组平分成众多子数组。然后对子数组应用选择排序或者其他的排序，将排好序的多个数组再应用选择排序或者其他排序，合并成一个排好序的数组。直到整个数组都排好序。



## 6. 归并排序的应用场景

- 数据量，数据规模较大时，应用归并会有比较好的效果。
- 一般应用在 **外排序** 上。**外排序** 是指处理 **超过内存限度** 的数据的排序算法，通常会将中间结果放在读写较慢的外存储器（通常为硬盘）上：
  - 排序阶段：读入能放在内存中的数据量，将其排序输出到临时文件，一次进行，将待排序数据组织为多个有序的临时文件。
  - 归并阶段：将这些临时文件组合为大的有序文件。



## 7. 什么排序是稳定的？什么是不稳定？

- **稳定** 的排序算法：冒泡，插入，基数
- **不稳定** 的排序算法：选择，快排，堆排，希尔，归并

感觉后面那个问题有点像问不稳定的概念。一个排序算法稳不稳定要看在排序过后，数组中相同的元素是否还会按原来的顺序出现。



## 8. 关于堆排序，堆顶元素被删除后，后面的操作？

堆排序堆顶元素被删除后，将堆顶替换为此时堆的最后一个元素，然后从堆顶开始维护这个大根堆 / 小根堆。重复删除堆顶操作，直到排序完成。



## 9. 在计网中，两个节点的最短路径？

感觉这跟计网也没啥关系？参考图的最短路径算法（后面出一篇博客仔细讲）。

有三种常见的求 **最短路径** 的算法：

- **Dijkstra 算法**。采用贪心的思想，从开始节点到结束节点开始遍历，更新当前节点到它下一个节点的最短路径，将当前节点加入到最短路径中。直到遍历到结束节点。有个缺陷是，这个算法只能解决**正权图的单源最短路径问题**，并不能解决负权图的最短路径。这是因为 Dijkstra 算法处理的是**已经处于集合中的点**，并没有考虑不在集合中的点。比如：
  - A - > B = 4, A - > C = 5, C - > B = -3。求 A -> B 的最短路径。此时会直接给出 A -> B = 4 的路径，而不再去考虑 A - > C - > B = 2。此时，得到的最短路径就是错的。
- **Floyd 算法**。维护两个二维数组 path 和 dis，path 中记录每个节点到另一个节点中的最短距离（类似于图的邻接矩阵），dis 中记录每个节点到另一个节点是否有中间节点可以中转导致距离最短。初始时 path 为节点到每一个节点的距离，然后遍历每个节点，使用当前节点作为中转站，更新两个二维数组。需要注意的是，dis 中放置的中转站只能有一个点。那么，如何判断经过多个点呢？比如一个图有节点 A B C，当求 AC 最短路径时，如果有中转点 B ，那么我们需要判断 AB，BC 是否有中转点，然后判断是否最短，并得到全部路径。
- **Bellman-ford 算法**。它普遍会比 Dijkstra 的时间复杂度高，但是它可以处理负权图。对于这个算法，有一个概念叫 **松弛** 操作。从求最短路径的起始点开始，对当前节点的每一条边进行松弛操作，松弛操作的做法是：
  - 当前节点有两个信息 n 和 length，n 表示从哪一个节点到当前节点，length 表示从 n 节点到当前节点的当前最短距离。
  - 当 **当前节点的当前最短距离 + 可到达的下一个节点的权重 < 下一个节点的当前最短距离** 时，更新下一个节点的信息。
  - 遍历所有边，直到遍历完成且节点松弛后无任何更新。



## 10. TCP 如何创建链接？创建链接的流程？

**如何创建：**三握手。

**流程：**

1. 客户端主动打开链接（结束 CLOSED 阶段），此时服务器端被动打开链接（结束 CLOSED 阶段，进入 LISTEN 阶段）。

2. 第一步握手，客户端向服务器发送一段 TCP 报文，其中：

   - 标记位为 SYN，表示 ”请求建立新连接“；
   - 序号为 seq = X （X 一般为 1）

   随后客户端进入 SYN-SENT 阶段。

3. 服务器接收来自客户端的 TCP 报文之后，结束 LISTEN 阶段。并返回响应报文：

   - 标志位为 SYN 和 ack，表示 ”确认客户端的报文 seq 有效，服务器能够正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端已接受到数据）
   - 序号为 seq = y
   - 确认号 ack = x + 1，表示收到客户端序号并将其加 1 作为确认号的值

   随后服务器端进入 SYN-RCVD 阶段。

4. 客户端接收到确认的数据报文后，明确客户端到服务器的数据传输时正常的，结束 SYN-SENT 阶段。并返回最后一段 TCP 报文：

   - 标志位 ack = y + 1，表示 “确认收到服务器端同意链接的确认号），将确认号设置为服务器端发送的序号 seq + 1。
   - 序号 seq = x + 1，表示收到确认号 ack，将序号设置为服务器端发送的确认号。

   随后客户端进入 ESTABLISHED 阶段。

5. 此时，服务器端收到了最后一段报文后，明确从服务器端到客户端的传输时正常的。结束 SYN-SENT 阶段，进入 ESTABLISHED 阶段。

在传输的 TCP 报文中，确认号与序号都是在彼此传输的确认号与序号的基础上进行计算的。这保证了 TCP 报文传输的连贯性。一旦报文丢失，则无法继续握手，以此确保三次握手的顺利进行。



## 11. 为什么需要三握手？两次或者一次握手不行吗？

主要是为了放置服务器端开启一些无用连接增加服务器开销，以及防止已失效的连接请求报文段突然又重新传到服务器端，因此产生了错误。

**一次握手**：如果只有一次握手，服务器端并不能知道这是否是一个有效的链接，客户端也并不知道服务器端是否成功接收了链接，并不能确保发送的数据服务器端是否能收到。

**两次握手**：如果只有两次握手，当服务器端将响应报文返回给客户端时，客户端发送第三次确认报文。如果客户端此时出错了，并没有发送确认报文，等超时重传时才继续进行握手。这时候，服务器端是一直在等待的（因为两次握手已经完成了，它认为链接已经成功建立），这样就会导致不必要的开销。

所以，三次握手是有必要的，它是保证 TCP 可靠连接以及节省资源的一大支持。



## 12. TCP 如何断开链接？断开连接的流程？

**如何断开**：四挥手。

**流程**：连接的释放（断开）必须是一方主动释放，另一方被动释放。以客户端发起释放连接为例：

1. 首先客户端主动想要释放连接，向服务器端发送一段报文：

   - 标志位 FIN，表示 “请求释放连接”
   - 序号 seq = U

   随后客户端进入 FIN-WAIT-1 阶段，即半关闭阶段。并且停止在客户端到服务器端方向发送的数据，但是客户端仍然可以接收服务器端传输的数据。

   注意，这里不发送正常连接时传输的数据（非确认报文），而不是全部数据，所以客户端仍然可以发送确认报文。

2. 服务器端接收到结束报文后，确认客户端想要释放连接，随后服务器端结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段（半关闭状态），并返回一段报文：

   - 标志位为 ack，表示 ”接收到客户端发送的释放连接的请求“
   - 序号 seq = V
   - 确认号为 ack = U + 1，表示是在收到客户端报文的基础上，将其序号 + 1 作为确认号的值。

   随后服务器端开始准备释放服务器端到客户端方向的连接。进入 CLOSE-WAIT 阶段。

   这两次挥手让服务器端知道了客户端想释放连接，也让客户端知道服务器端了解到了想要释放连接的请求。此时，客户端可以确认关闭客户端到服务器端的连接了，并进入 FIN-WAIT-2 阶段。

3. 当服务器端发出确认报文后，经过 CLOSED-WAIT 阶段，做好了释放服务器端到客户端方向连接的准备，再次向客户端发出报文：

   - 标志位 FIN, ACK，表示 ”已经准备好释放连接“。这里的 ACK 并不是确认收到服务器端报文的确认报文。
   - 序号 seq = W
   - ack = U + 1，表示在收到客户端报文的基础上，将其序号 + 1 作为确认号的值。

   随后服务器端结束 CLOSED-WAIT 阶段，进入 LAST-ACK 阶段。停止在服务器端到客户端方向发送数据，但是服务器端仍能接收从客户端传来的数据。

4. 客户端接收到服务器端发出的 TCP 报文，确认服务器端做好释放连接的准备，结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器端发送报文：

   - 标志位 ack ，表示 ”接收到服务器准备好释放连接的信号“
   - 序号为 seq = U + 1，表示在收到服务器报文的基础上，将其确认号 ack 作为本段报文序号的值
   - 确认号 ack = W + 1，表示收到服务器报文的基础上，将其序号作为本段报文确认号的值。



## 13. 为什么客户端需要等待 2MSL？

等待 2MSL 是为了确认服务器端是否收到客户端的 ACK 确认报文，服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。由此正确确认关闭服务器端到客户端的连接。

此时，如果服务器端没有收到确认报文，代表连接其实没有断开成功。会重新发送以保证连接能够正常断开。



## 14. 为什么需要四挥手？

这是因为，服务器端不可能说断开就断开，它先要明确自己收到了客户端的请求（第二次挥手），然后它需要等待自己的数据传输完成后，准备好断开了，才能断开（第三次挥手）。



## 15. TCP 是什么？

TCP 是 Transmission Control Protocol 的简称，中文名是传输控制协议。它是一种面向连接的，可靠的，基于字节流的传输层协议。



## 16. UDP 是什么？

UDP 是 User Datagram Protocol 的简称，中文名是用户数据报协议。是 OSI 参考模型中的传输层协议，它是一种无连接的提供面向事务的**简单不可靠信息传送服务**。也就是说，它无法保证报文是否能够安全完整到达。

**拓展**（没问别答）

它的格式有两个部分

- 首部：它包括：
  - 源端口：2 字节，表示源端口号
  - 目的端口：2 字节，表示目的端口号
  - 长度：2 字节，校验 UDP 数据报的数据字段和包含 UDP 数据报首部的**伪首部**。其校验方法用 IP 分组首部校验和。伪首部是指在 TCP 分段或者 UDP 的数据报格式中，在数据报首部前加上源 IP 地址，目的 IP 地址，IP 地址分组和协议字段。它是一个临时结构，既不向上也不向下传递，仅仅只是为了保证可以校验套接字的正确性。
- 数据：顾名思义是传输的数据。



## 17. OSI 参考（七层）模型？

开放系统互联（Open System Interconnection）。但随着时代的发展，逐渐被 TCP/IP 4 层模型淘汰。

OSI 分为 7 层，从上到下依次是：

- 应用层，网络服务与最终客户的一个接口（可以理解为人机交互画面）
- 表示层，数据的表示，安全，压缩（翻译成机器语言）
- 会话层，建立，管理，终止会话（传输到哪里，建立会话。或者哪里传输过来）
- 传输层，定义传输协议的协议端口号，以及控流和差错校验（定义怎么传输）
- 网络层，逻辑地址寻址，实现不同网络间的路径选择（找到需要传输到哪，这个哪的 ip 地址）
- 数据链路层，建立逻辑链接，进行硬件地址寻址，差错校验等功能（通过网卡，进行传输）
- 物理层，建立，维护，断开物理连接（变成信号传输啊啥的，就是真正的传输过去）



## 18. TCP/IP 四层模型？

TCP/IP 四层模型就是将 OSI 七层模型中的上三层变为了应用层。

它相对于 OSI 七层模型来说，更简单，成本更低，效率也更高。



## 19. QUIC 协议

QUIC: quick UDP internet connections，是一种基于 UDP 的传输层协议。



## 20. 什么是 IO 多路复用

IO 多路复用是指单线程或者单进程同时监测若干个文件描述符是否可以执行 IO 操作的能力。它用来在单线程 / 单进程中处理多个事件流，用更少的资源去完成更多的事。

**拓展**

目前 Linux 系统提供了五种 IO 处理模型：

- 阻塞 IO，最简单最常用的 IO 模型。当我们发起一次 IO 操作后，一直等待成功或者失败之后才返回。在此期间程序不能做其他的事情。阻塞 IO 只能对单个文件描述符进行操作，通过调用 read 和 write 进行操作。
- 非阻塞 IO，非阻塞 IO 通常发生在一个 for 循环中，因为每次进行 IO 操作时，要么 IO 操作成功，要么当 IO 操作会阻塞时返回错误。然后根据需要进行的下一次 for 循环操作。这是一种糟糕的设计，因为它类似于轮询，会浪费不少 CPU 资源。它同样只能对单个文件描述符进行操作，通过调用 read 和 write 进行操作。
- IO 多路复用
- 信号驱动 IO，利用信号机制，让内核告知应用程序文件描述符的相关时间。在网络编程中很少用到，这是因为和 socket 相关的读写时间太多了，无法区分不同的时间。它应该只在 IO 时间单一情况下使用。
- 异步 IO，和信号驱动 IO 差不多。在信号驱动 IO 中，需要在程序中完成数据从用户态到内核态（或反方向）的拷贝。异步 IO 可以把这一步完成之后才通知应用程序。也就是说，异步 IO 中的异步是指 IO 操作不会阻塞当前程序的继续执行。



## 21. MySQL 有几种隔离级别？

可见 [MySQL 概念梳理](https://hardews.cn/mysql-concept-study)

有四种隔离级别：

- 读未提交（ru），事务 A 可以读到事务 B 未提交的，已更改的数据。
- 读已提交（rc），事务 A 可以读到事务 B 已提交的数据，未提交的无法读取。Oracle 的默认隔离级别就是 rc。
- 可重复读（rr），事务 A 第一次读取数据为 a，未提交。事务 B 在事务 A 第一次读取后将数据更改并提交此数据变为 b，但事务 A 第二次读取数据仍未 a。此为可重复读。
- 串行化，事务 A 在执行事务时，后访问的事务 B 必须等待事务 A 提交或者回滚后，才能执行。



## 22. MySQL 为什么选择 B+ 树，而不是 B 树？

B+ 树作为 MySQL 索引的主要数据结构，它的优势是：

树非常矮，然后存放的排序数据多。这意味着从千万或者上亿数据查询一条数据，只需要 3、4 次 IO。

索引，索引是提升查询速度的一种数据结构。



## 参考面经

[腾讯后端一面_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/536925650649673728?sourceSSR=search)

